var ftc=function(t){"use strict";function n(t){const n=(t=a(t)).length,e=n-1,r=new Array(n);for(let a=0;a<n;++a){let o=t[a],i=a,c=Math.abs(o[a]);for(let e=a+1;e<n;++e){const n=Math.abs(t[e][a]);c<n&&(c=n,i=e)}r[a]=i,i!=a&&(t[a]=t[i],t[i]=o,o=t[a]);const s=o[a];for(let e=a+1;e<n;++e)t[e][a]/=s;for(let r=a+1;r<n;++r){const n=t[r];let i;for(i=a+1;i<e;++i)n[i]-=n[a]*o[i],++i,n[i]-=n[a]*o[i];i===e&&(n[i]-=n[a]*o[i])}}return{LU:t,P:r}}function e(t,n){var e=t.LU,r=e.length,o=a(n),i=t.P;for(let a=r-1;-1!==a;--a)o[a]=n[a];for(let a=0;a<r;++a){const t=i[a],n=e[a];if(i[a]!==a){const n=o[a];o[a]=o[t],o[t]=n}for(let e=0;e<a;++e)o[a]-=o[e]*n[e]}for(let a=r-1;a>=0;--a){const t=e[a];for(let n=a+1;n<r;++n)o[a]-=o[n]*t[n];o[a]/=t[a]}return o}function a(t){return Array.isArray(t)?t.map((t=>a(t))):t}function r(){return[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]}function o(t){return t[0].map(((n,e)=>t.map((t=>t[e]))))}function i(t,n){return t.map(((e,a)=>t[a]*n[a])).reduce(((t,n)=>t+n))}function c(t,n){return t.map((t=>o(n).map((n=>i(t,n)))))}function s(...t){let n=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];for(let e of t)n=c(n,e);return n}function u(t,n){const e=f(t,n);return[e[0]/e[2],e[1]/e[2]]}function l(t,n){return n.map((n=>u(t,n)))}function f(t,n=[0,0]){return[t[0][0]*n[0]+t[0][1]*n[1]+t[0][3],t[1][0]*n[0]+t[1][1]*n[1]+t[1][3],t[3][0]*n[0]+t[3][1]*n[1]+t[3][3]]}function h(t,n){return[[1,0,0,t],[0,1,0,n],[0,0,1,0],[0,0,0,1]]}function m(t,n){const e=Math.cos(t),a=Math.sin(t),r=[[e,-a,0,0],[a,e,0,0],[0,0,1,0],[0,0,0,1]];return n?s(h(n[0],n[1]),r,h(-n[0],-n[1])):r}function x(t,n,e){const a=[[t,0,0,0],[0,n,0,0],[0,0,1,0],[0,0,0,1]];return e?s(h(e[0],e[1]),a,h(-e[0],-e[1])):a}function M(t){const n={scale:{sx:0,sy:0},rotation:{angle:0}},[[e,a],[r,o]]=t;if(0!==e||0!==r){const t=Math.hypot(e,r);n.scale.sx=t,n.scale.sy=(e*o-a*r)/t;const i=Math.acos(e/t);n.rotation.angle=r>0?-i:i}else if(0!==a||0!==e){const t=Math.hypot(a,o);n.scale.sx=(e*o-a*r)/t,n.scale.sy=t;const i=Math.acos(r/t);n.rotation.angle=Math.PI/2+(o>0?-i:i)}return n}const p=t=>{const n=t.reduce(((t,n)=>(t.xmin=Math.min(t.xmin,n[0]),t.xmax=Math.max(t.xmax,n[0]),t.ymin=Math.min(t.ymin,n[1]),t.ymax=Math.max(t.ymax,n[1]),t)),{xmin:1/0,xmax:-1/0,ymin:1/0,ymax:-1/0});return{...n,width:n.xmax-n.xmin,height:n.ymax-n.ymin}};function g(t,n){return[[0,0],[0,n],[t,0],[t,n]]}const y=(t,n=[0,0])=>Math.atan2(n[1]-t[1],t[0]-n[0]),d=t=>t*(Math.PI/180),P=t=>t*(180/Math.PI),w=([t,n],e)=>{const a=Math.sin(e),r=Math.cos(e);return[t*r+n*a,n*r-t*a]};function v(t,...n){return"function"==typeof t?t(...n):t}function A(t,n,e){return Math.max(n,Math.min(t,e))}const X=(t,n)=>Math.sqrt((n[0]-t[0])*(n[0]-t[0])+(n[1]-t[1])*(n[1]-t[1]));const Y=[[0,1,2],[1,0,3],[2,0,3],[3,1,2]];function I(t,n,e){const a=y(t,e)-y(t,n);return a>=0?a:a+2*Math.PI}const b=[[0,0],[0,1],[1,0],[1,1]];return t.applyToPoint=u,t.applyToPoints=l,t.call=function(t,...n){t&&t(...n)},t.clamp=A,t.createMatrixFromParams=function({scaleX:t=1,scaleY:n=1,angle:e=0,width:a=0,height:r=0}={}){return c(x(t,n),m(e,[a/2,r/2]))},t.decompose=M,t.dotProduct=i,t.getAngle=y,t.getDistance=X,t.getPointAtAngle=w,t.getVector=f,t.identity=r,t.inverseAffine=function(t){const n=t[0][0]*t[1][1]-t[0][1]*t[1][0];return[[t[1][1]/n,t[0][1]/-n,0,(t[1][1]*t[0][3]-t[1][0]*t[1][3])/-n],[t[1][0]/-n,t[0][0]/n,0,(t[0][1]*t[0][3]-t[0][0]*t[1][3])/n],[0,0,1,0],[0,0,0,1]]},t.lu=n,t.luSolve=e,t.makePerspectiveMatrix=function(t,a){const r=[];for(let n=0;n<4;n++)r.push([t[n][0],t[n][1],1,0,0,0,-t[n][0]*a[n][0],-t[n][1]*a[n][0]],[0,0,0,t[n][0],t[n][1],1,-t[n][0]*a[n][1],-t[n][1]*a[n][1]]);const o=e(n(r),a.reduce(((t,n)=>[...t,...n]),[]));return[[o[0],o[1],0,o[2]],[o[3],o[4],0,o[5]],[0,0,1,0],[o[6],o[7],0,1]]},t.makeWarpPoints=g,t.matrixRotate=m,t.matrixScale=x,t.matrixTranslate=h,t.minMax=p,t.multiplies=s,t.multiply=c,t.rotate=function({x:t,y:n,width:e,height:a,start:r,offset:o,origin:i,affineMatrix:s,matrix:l,snapDegree:f=15,snap:h},x){const p=M(s).rotation.angle,g=P(p),y=u(l,[e*i[0],a*i[1]]),w=Math.atan2(r[1]-o[1]-(y[1]+n),r[0]-o[0]-(y[0]+t));return e=>{let a=p+Math.atan2(e.clientY-o[1]-(y[1]+n),e.clientX-o[0]-(y[0]+t))-w,r=P(a);v(h,e)&&(r=Math.round(r/f)*f),r-=g,x({matrix:c(m(d(r),y),s)})}},t.scale=function(t,{start:n,width:e,height:a,fromCenter:r=(()=>!1),aspectRatio:o=(()=>!1),matrix:i,affineMatrix:s,perspectiveMatrix:f,scaleLimit:h},m){const y=M(s),d=p(l(i,g(e,a))),P=y.rotation.angle,X=[n[0],n[1]];return n=>{const i=v(r,n)?[.5,.5]:[1-t[0],1-t[1]],l=[n.clientX,n.clientY];let M=w([l[0]-X[0],l[1]-X[1]],-P);M[0]/=y.scale.sx,M[1]/=y.scale.sy;const p=u(f,[e*t[0],a*t[1]]),g=u(f,[e*i[0],a*i[1]]),Y=[1,1];0!==t[0]&&1!==t[0]||(Y[0]=(p[0]+M[0]-g[0])/(p[0]-g[0])),0!==t[1]&&1!==t[1]||(Y[1]=(p[1]+M[1]-g[1])/(p[1]-g[1]));const I=u(f,[e*i[0],a*i[1]]);if(v(o,n))if(0===t[0]||1===t[0]){const t=d.width/d.height;Y[1]=d.width*Y[0]*(1/t)/d.height}else if(0===t[1]||1===t[1]){const t=d.height/d.width;Y[0]=a*Y[1]*t/e}h&&(Y[0]=A(Y[0],h[0],h[1]),Y[1]=A(Y[1],h[0],h[1])),m({matrix:c(s,x(Y[0],Y[1],I))})}},t.toDegree=P,t.toRadians=d,t.translate=function({x:t,y:n,start:e},a){return r=>{t+=r.clientX-e[0],n+=r.clientY-e[1],a({x:t,y:n}),e=[r.clientX,r.clientY]}},t.transpose=o,t.value=v,t.warp=function(t,{affineMatrix:n,handles:e,start:a},r){const o=M(n),i=o.rotation.angle,c=0!==t[0]&&1!==t[0]||0!==t[1]&&1!==t[1]?2:1,s=function(t,n,e=1){return n.map(((n,e)=>[e,X(t,n)])).sort(((t,n)=>t[1]-n[1])).slice(0,e)}(t,b,c).map((t=>t[0]));return t=>{const n=[t.clientX,t.clientY];let c=w([n[0]-a[0],n[1]-a[1]],-i);c[0]/=o.scale.sx,c[1]/=o.scale.sy;const u=e.map(((t,n)=>s.includes(n)?[t[0]+c[0],t[1]+c[1]]:t));(function(t,n){for(let e=0;e<t.length;e++){const a=Y[e],r=I(t[a[0]],t[a[1]],t[a[2]]),o=I(n[a[0]],n[a[1]],n[a[2]]),i=Math.PI;if(r>=i&&o<=i||r<=i&&o>=i)return!0}return!1})(u,e)||r({warp:u})}},Object.defineProperties(t,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}}),t}({});
