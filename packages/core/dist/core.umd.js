!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).ftc={})}(this,(function(t){"use strict";function n(t){const n=(t=a(t)).length,e=n-1,o=new Array(n);for(let a=0;a<n;++a){let r=t[a],i=a,c=Math.abs(r[a]);for(let e=a+1;e<n;++e){const n=Math.abs(t[e][a]);c<n&&(c=n,i=e)}o[a]=i,i!=a&&(t[a]=t[i],t[i]=r,r=t[a]);const s=r[a];for(let e=a+1;e<n;++e)t[e][a]/=s;for(let o=a+1;o<n;++o){const n=t[o];let i;for(i=a+1;i<e;++i)n[i]-=n[a]*r[i],++i,n[i]-=n[a]*r[i];i===e&&(n[i]-=n[a]*r[i])}}return{LU:t,P:o}}function e(t,n){var e=t.LU,o=e.length,r=a(n),i=t.P;for(let a=o-1;-1!==a;--a)r[a]=n[a];for(let a=0;a<o;++a){const t=i[a],n=e[a];if(i[a]!==a){const n=r[a];r[a]=r[t],r[t]=n}for(let e=0;e<a;++e)r[a]-=r[e]*n[e]}for(let a=o-1;a>=0;--a){const t=e[a];for(let n=a+1;n<o;++n)r[a]-=r[n]*t[n];r[a]/=t[a]}return r}function a(t){return Array.isArray(t)?t.map((t=>a(t))):t}function o(){return[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]}function r(t){return t[0].map(((n,e)=>t.map((t=>t[e]))))}function i(t,n){return t.map(((e,a)=>t[a]*n[a])).reduce(((t,n)=>t+n))}function c(t,n){return t.map((t=>r(n).map((n=>i(t,n)))))}function s(...t){let n=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];for(let e of t)n=c(n,e);return n}function l(t,n){const e=f(t,n);return[e[0]/e[2],e[1]/e[2]]}function u(t,n){return n.map((n=>l(t,n)))}function f(t,n=[0,0]){return[t[0][0]*n[0]+t[0][1]*n[1]+t[0][3],t[1][0]*n[0]+t[1][1]*n[1]+t[1][3],t[3][0]*n[0]+t[3][1]*n[1]+t[3][3]]}function h(t,n){return[[1,0,0,t],[0,1,0,n],[0,0,1,0],[0,0,0,1]]}function m(t,n){const e=Math.cos(t),a=Math.sin(t),o=[[e,-a,0,0],[a,e,0,0],[0,0,1,0],[0,0,0,1]];return n?s(h(n[0],n[1]),o,h(-n[0],-n[1])):o}function x(t,n,e){const a=[[t,0,0,0],[0,n,0,0],[0,0,1,0],[0,0,0,1]];return e?s(h(e[0],e[1]),a,h(-e[0],-e[1])):a}function p(t){const n={scale:{sx:0,sy:0},rotation:{angle:0}},[[e,a],[o,r]]=t;if(0!==e||0!==o){const t=Math.hypot(e,o);n.scale.sx=t,n.scale.sy=(e*r-a*o)/t;const i=Math.acos(e/t);n.rotation.angle=o>0?-i:i}else if(0!==a||0!==e){const t=Math.hypot(a,r);n.scale.sx=(e*r-a*o)/t,n.scale.sy=t;const i=Math.acos(o/t);n.rotation.angle=Math.PI/2+(r>0?-i:i)}return n}const M=t=>{const n=t.reduce(((t,n)=>(t.xmin=Math.min(t.xmin,n[0]),t.xmax=Math.max(t.xmax,n[0]),t.ymin=Math.min(t.ymin,n[1]),t.ymax=Math.max(t.ymax,n[1]),t)),{xmin:1/0,xmax:-1/0,ymin:1/0,ymax:-1/0});return{...n,width:n.xmax-n.xmin,height:n.ymax-n.ymin}};function y(t,n){return[[0,0],[0,n],[t,0],[t,n]]}const d=(t,n=[0,0])=>Math.atan2(n[1]-t[1],t[0]-n[0]),g=t=>t*(Math.PI/180),P=t=>t*(180/Math.PI),w=([t,n],e)=>{const a=Math.sin(e),o=Math.cos(e);return[t*o+n*a,n*o-t*a]};function v(t,...n){return"function"==typeof t?t(...n):t}function b(t,n,e){return Math.max(n,Math.min(t,e))}const A=(t,n)=>Math.sqrt((n[0]-t[0])*(n[0]-t[0])+(n[1]-t[1])*(n[1]-t[1]));const T=[[0,1,2],[1,0,3],[2,0,3],[3,1,2]];function X(t,n,e){const a=d(t,e)-d(t,n);return a>=0?a:a+2*Math.PI}const Y=[[0,0],[0,1],[1,0],[1,1]];t.applyToPoint=l,t.applyToPoints=u,t.call=function(t,...n){t&&t(...n)},t.clamp=b,t.createMatrixFromParams=function({scaleX:t=1,scaleY:n=1,angle:e=0,width:a=0,height:o=0}={}){return c(x(t,n),m(e,[a/2,o/2]))},t.decompose=p,t.dotProduct=i,t.getAngle=d,t.getDistance=A,t.getPointAtAngle=w,t.getVector=f,t.identity=o,t.inverseAffine=function(t){const n=t[0][0]*t[1][1]-t[0][1]*t[1][0];return[[t[1][1]/n,t[0][1]/-n,0,(t[1][1]*t[0][3]-t[1][0]*t[1][3])/-n],[t[1][0]/-n,t[0][0]/n,0,(t[0][1]*t[0][3]-t[0][0]*t[1][3])/n],[0,0,1,0],[0,0,0,1]]},t.lu=n,t.luSolve=e,t.makePerspectiveMatrix=function(t,a){const o=[];for(let n=0;n<4;n++)o.push([t[n][0],t[n][1],1,0,0,0,-t[n][0]*a[n][0],-t[n][1]*a[n][0]],[0,0,0,t[n][0],t[n][1],1,-t[n][0]*a[n][1],-t[n][1]*a[n][1]]);const r=e(n(o),a.reduce(((t,n)=>[...t,...n]),[]));return[[r[0],r[1],0,r[2]],[r[3],r[4],0,r[5]],[0,0,1,0],[r[6],r[7],0,1]]},t.makeWarpPoints=y,t.matrixRotate=m,t.matrixScale=x,t.matrixTranslate=h,t.minMax=M,t.multiplies=s,t.multiply=c,t.rotate=function({x:t,y:n,width:e,height:a,start:o,offset:r,origin:i,affineMatrix:s,matrix:u,snapDegree:f=15,snap:h},x){const M=p(s).rotation.angle,y=P(M),d=l(u,[e*i[0],a*i[1]]),w=Math.atan2(o[1]-r[1]-(d[1]+n),o[0]-r[0]-(d[0]+t));return e=>{let a=M+Math.atan2(e.clientY-r[1]-(d[1]+n),e.clientX-r[0]-(d[0]+t))-w,o=P(a);v(h,e)&&(o=Math.round(o/f)*f),o-=y,x({matrix:c(m(g(o),d),s)})}},t.scale=function(t,{start:n,width:e,height:a,fromCenter:o=(()=>!1),aspectRatio:r=(()=>!1),matrix:i,affineMatrix:s,perspectiveMatrix:f,scaleLimit:h},m){const d=p(s),g=M(u(i,y(e,a))),P=d.rotation.angle,A=[n[0],n[1]];return n=>{const i=v(o,n)?[.5,.5]:[1-t[0],1-t[1]],u=[n.clientX,n.clientY];let p=w([u[0]-A[0],u[1]-A[1]],-P);p[0]/=d.scale.sx,p[1]/=d.scale.sy;const M=l(f,[e*t[0],a*t[1]]),y=l(f,[e*i[0],a*i[1]]),T=[1,1];0!==t[0]&&1!==t[0]||(T[0]=(M[0]+p[0]-y[0])/(M[0]-y[0])),0!==t[1]&&1!==t[1]||(T[1]=(M[1]+p[1]-y[1])/(M[1]-y[1]));const X=l(f,[e*i[0],a*i[1]]);if(v(r,n))if(0===t[0]||1===t[0]){const t=g.width/g.height;T[1]=g.width*T[0]*(1/t)/g.height}else if(0===t[1]||1===t[1]){const t=g.height/g.width;T[0]=a*T[1]*t/e}h&&(T[0]=b(T[0],h[0],h[1]),T[1]=b(T[1],h[0],h[1])),m({matrix:c(s,x(T[0],T[1],X))})}},t.toDegree=P,t.toRadians=g,t.translate=function({x:t,y:n,start:e},a){return o=>{t+=o.clientX-e[0],n+=o.clientY-e[1],a({x:t,y:n}),e=[o.clientX,o.clientY]}},t.transpose=r,t.value=v,t.warp=function(t,{affineMatrix:n,handles:e,start:a},o){const r=p(n),i=r.rotation.angle,c=0!==t[0]&&1!==t[0]||0!==t[1]&&1!==t[1]?2:1,s=function(t,n,e=1){return n.map(((n,e)=>[e,A(t,n)])).sort(((t,n)=>t[1]-n[1])).slice(0,e)}(t,Y,c).map((t=>t[0]));return t=>{const n=[t.clientX,t.clientY];let c=w([n[0]-a[0],n[1]-a[1]],-i);c[0]/=r.scale.sx,c[1]/=r.scale.sy;const l=e.map(((t,n)=>s.includes(n)?[t[0]+c[0],t[1]+c[1]]:t));(function(t,n){for(let e=0;e<t.length;e++){const a=T[e],o=X(t[a[0]],t[a[1]],t[a[2]]),r=X(n[a[0]],n[a[1]],n[a[2]]),i=Math.PI;if(o>=i&&r<=i||o<=i&&r>=i)return!0}return!1})(l,e)||o({warp:l})}},Object.defineProperties(t,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
